<!DOCTYPE html><html lang=zh-CN><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content=rgba(0,0,0,0)><meta name=generator content="Hexo 6.3.0"><link rel=preconnect href=//fonts.loli.net crossorigin><link rel=preconnect href=null//null crossorigin><link rel=preconnect href=https://cdn.jsdelivr.net crossorigin><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/images/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/images/favicon-16x16.png><link rel=mask-icon href=/images/logo.svg color=rgba(0,0,0,0)><link rel=manifest href=/images/manifest.json><link rel=stylesheet href=/css/main.css><link rel=stylesheet href="//fonts.loli.net/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/orange/pace-theme-big-counter.css><script src=https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin=anonymous></script><script class=next-config data-name=main type=application/json>{"hostname":"blog.bysegfault.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"buttons","active":"disqus","storage":true,"lazyload":false,"nav":{"disqus":{"text":"Load Disqus","order":-1}},"activeClass":"disqus"},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta name=description content="树与森林  这就是两棵树，暂且称左边的为树A,右边的为树B，很明显，我们调换树A的b、c的顺序，两棵树就相同了。 按照这种思路，树可以分为有序树和无序树。  树  有序树 无序树    有序树：树A和树B不同，因为左右有次序，不能颠倒。 无序树：树A和树B相同，可以颠倒次序。 这就是树啦，那么森林顾名思义，就是很多的树。 树A与树B共同在一起就是一个森林。 森林就是这样很多不相交的树组成，同时仅"><meta property=og:type content=blog><meta property=og:title content=树与二叉树><meta property=og:url content=https://blog.bysegfault.com/CS/dataStruct/tree/tree/index.html><meta property=og:site_name content="ohayo&#39;s blog"><meta property=og:description content="树与森林  这就是两棵树，暂且称左边的为树A,右边的为树B，很明显，我们调换树A的b、c的顺序，两棵树就相同了。 按照这种思路，树可以分为有序树和无序树。  树  有序树 无序树    有序树：树A和树B不同，因为左右有次序，不能颠倒。 无序树：树A和树B相同，可以颠倒次序。 这就是树啦，那么森林顾名思义，就是很多的树。 树A与树B共同在一起就是一个森林。 森林就是这样很多不相交的树组成，同时仅"><meta property=og:locale content=zh_CN><meta property=og:image content=https://s2.loli.net/2022/09/19/zjuKDBnc6d8kTNZ.png><meta property=og:image content=https://s2.loli.net/2022/09/19/xy1uo64FKhNpOLj.png><meta property=og:image content=https://s2.loli.net/2022/09/19/DtUOaJXk3rq8xgi.png><meta property=og:image content=https://s2.loli.net/2022/09/19/xy1uo64FKhNpOLj.png><meta property=og:image content=https://s2.loli.net/2022/09/19/DtUOaJXk3rq8xgi.png><meta property=og:image content=https://s2.loli.net/2022/09/19/z43TM2bBVn7k6O9.png><meta property=og:image content=https://s2.loli.net/2022/09/19/3HBActni5fpJg4k.png><meta property=og:image content=https://s2.loli.net/2022/09/19/Ab9iseSdIC52pBJ.png><meta property=og:image content=https://s2.loli.net/2022/09/19/z43TM2bBVn7k6O9.png><meta property=og:image content=https://s2.loli.net/2022/09/19/7DMOp2HcqiNQZgk.png><meta property=og:image content=https://s2.loli.net/2022/09/19/z43TM2bBVn7k6O9.png><meta property=og:image content=https://s2.loli.net/2022/09/19/z43TM2bBVn7k6O9.png><meta property=og:image content=https://s2.loli.net/2022/09/19/xr9MZlQiavbqnC1.png><meta property=og:image content=https://s2.loli.net/2022/09/19/J2a1zEeOnkrwYlQ.png><meta property=og:image content=https://s2.loli.net/2022/09/19/dtplzwjrPnHSW5B.png><meta property=og:image content=https://s2.loli.net/2022/09/19/dtplzwjrPnHSW5B.png><meta property=og:image content=https://s2.loli.net/2022/09/20/JZrOpeV6hndyqPW.png><meta property=og:image content=https://s2.loli.net/2022/09/20/wZ4HhSRQ2F8xcpJ.png><meta property=og:image content=https://s2.loli.net/2022/09/20/LXNDH89l2Wio5Ma.png><meta property=og:image content=https://s2.loli.net/2022/09/20/5FUDOQfnERy4TjK.png><meta property=og:image content=https://s2.loli.net/2022/09/19/dtplzwjrPnHSW5B.png><meta property=og:image content=https://s2.loli.net/2022/09/20/LXNDH89l2Wio5Ma.png><meta property=article:published_time content=2022-09-19T04:24:13.000Z><meta property=article:modified_time content=2024-11-23T13:39:43.353Z><meta property=article:author content=ohayo><meta property=article:tag content=note><meta name=twitter:card content=summary><meta name=twitter:image content=https://s2.loli.net/2022/09/19/zjuKDBnc6d8kTNZ.png><link rel=canonical href=https://blog.bysegfault.com/CS/dataStruct/tree/tree/ ><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.bysegfault.com/CS/dataStruct/tree/tree/","path":"CS/dataStruct/tree/tree/","title":"树与二叉树"}</script><script class=next-config data-name=calendar type=application/json>""</script><title>树与二叉树 | ohayo's blog</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label=切换导航栏 role=button><span class=toggle-line></span> <span class=toggle-line></span> <span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><p class=site-title>ohayo's blog</p><i class=logo-line></i></a></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-journal"><a href=/categories/journal/index.html rel=section><i class="fa fa-book-journal-whills fa-fw"></i>Journal</a></li><li class="menu-item menu-item-test"><a href=https://test.ohayo.live/ rel=noopener target=_blank><i class="fa fa-book fa-fw"></i>Test</a></li><li class="menu-item menu-item-friend"><a href=/friends/index.html rel=section><i class="fa fa-link fa-fw"></i>Friend</a></li><li class="menu-item menu-item-about"><a href=/about/index.html rel=section><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-search"><a role=button class=popup-trigger><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span> <span class=toggle-line></span> <span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97><span class=nav-number>1.</span> <span class=nav-text>树与森林</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%9C%AF%E8%AF%AD%E4%BB%8B%E7%BB%8D><span class=nav-number>1.1.</span> <span class=nav-text>术语介绍</span></a></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8><span class=nav-number>1.2.</span> <span class=nav-text>树的性质</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%80%BB%E7%BB%93><span class=nav-number>1.2.1.</span> <span class=nav-text>总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class=nav-link href=#%E4%BA%8C%E5%8F%89%E6%A0%91><span class=nav-number>2.</span> <span class=nav-text>二叉树</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8><span class=nav-number>2.1.</span> <span class=nav-text>二叉树的性质</span></a></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8><span class=nav-number>2.2.</span> <span class=nav-text>二叉树的存储</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8><span class=nav-number>2.2.1.</span> <span class=nav-text>顺序存储</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8><span class=nav-number>2.2.2.</span> <span class=nav-text>链式存储</span></a></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86><span class=nav-number>2.3.</span> <span class=nav-text>二叉树的遍历</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86><span class=nav-number>2.3.1.</span> <span class=nav-text>先序遍历</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86><span class=nav-number>2.3.2.</span> <span class=nav-text>中序遍历</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86><span class=nav-number>2.3.3.</span> <span class=nav-text>后序遍历</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%B1%82%E9%81%8D%E5%8E%86><span class=nav-number>2.3.4.</span> <span class=nav-text>层遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C%E7%A1%AE%E5%AE%9A%E4%BA%8C%E5%8F%89%E6%A0%91><span class=nav-number>2.4.</span> <span class=nav-text>遍历结果确定二叉树</span></a></li><li class="nav-item nav-level-2"><a class=nav-link href=#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C><span class=nav-number>2.5.</span> <span class=nav-text>二叉树的操作</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%94%9F%E6%88%90><span class=nav-number>2.5.1.</span> <span class=nav-text>生成</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%A0%91><span class=nav-number>2.5.2.</span> <span class=nav-text>删除二叉树</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%A4%8D%E5%88%B6><span class=nav-number>2.5.3.</span> <span class=nav-text>复制</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6><span class=nav-number>2.5.4.</span> <span class=nav-text>计算二叉树深度</span></a></li><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E6%95%B0><span class=nav-number>2.5.5.</span> <span class=nav-text>二叉树叶子结点数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%BC%95%E7%94%A8><span class=nav-number>3.</span> <span class=nav-text>引用</span></a></li><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81><span class=nav-number>4.</span> <span class=nav-text>完整代码</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=ohayo src=/images/avatar.png><p class=site-author-name itemprop=name>ohayo</p><div class=site-description itemprop=description></div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/ ><span class=site-state-item-count>28</span> <span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/ ><span class=site-state-item-count>22</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/ ><span class=site-state-item-count>17</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author site-overview-item animated"><span class=links-of-author-item><a href=https://github.com/zhu-jiyuan title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhu-jiyuan" rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class=links-of-author-item><a href=mailto:ohayo1213@outlook.com title="E-Mail → mailto:ohayo1213@outlook.com" rel=noopener target=_blank><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class=links-of-author-item><a href=/atom.xml title="RSS → &#x2F;atom.xml"><i class="fa-solid fa-square-rss fa-fw"></i>RSS</a></span></div></div></div><div class="back-to-top animated" role=button aria-label=返回顶部><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div class=sidebar-dimmer></div></header><div class=reading-progress-bar></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang=zh-CN><link itemprop=mainEntityOfPage href=https://blog.bysegfault.com/CS/dataStruct/tree/tree/ ><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content=/images/avatar.png><meta itemprop=name content=ohayo></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="ohayo's blog"><meta itemprop=description content=""></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="树与二叉树 | ohayo's blog"><meta itemprop=description content=""></span><header class=post-header><h1 class=post-title itemprop="name headline">树与二叉树</h1><div class=post-meta-container><div class=post-meta><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i> </span><span class=post-meta-item-text>发表于</span> <time title="创建时间：2022-09-19 12:24:13" itemprop="dateCreated datePublished" datetime=2022-09-19T12:24:13+08:00>2022-09-19</time> </span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i> </span><span class=post-meta-item-text>更新于</span> <time title="修改时间：2024-11-23 21:39:43" itemprop=dateModified datetime=2024-11-23T21:39:43+08:00>2024-11-23</time> </span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder"></i> </span><span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/CS/ itemprop=url rel=index><span itemprop=name>CS</span></a> </span>， <span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/CS/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ itemprop=url rel=index><span itemprop=name>数据结构</span></a> </span></span><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-comment"></i> </span><span class=post-meta-item-text>Disqus：</span> <a title=disqus href=/CS/dataStruct/tree/tree/#disqus_thread itemprop=discussionUrl><span class="post-comments-count disqus-comment-count" data-disqus-identifier=CS/dataStruct/tree/tree/ itemprop=commentCount></span></a></span></div></div></header><div class=post-body itemprop=articleBody><h1 id=树与森林><a class=markdownIt-Anchor href=#树与森林></a> 树与森林</h1><p><img data-src=https://s2.loli.net/2022/09/19/zjuKDBnc6d8kTNZ.png alt=image-20220919163736434></p><p>这就是两棵树，暂且称左边的为<code>树A</code>,右边的为<code>树B</code>，很明显，我们调换树A的b、c的顺序，两棵树就相同了。</p><p>按照这种思路，树可以分为有序树和无序树。</p><ul><li>树<ul><li>有序树</li><li>无序树</li></ul></li></ul><p>有序树：树A和树B不同，因为左右有次序，不能颠倒。</p><p>无序树：树A和树B相同，可以颠倒次序。</p><p>这就是树啦，那么森林顾名思义，就是很多的树。</p><p>树A与树B共同在一起就是一个森林。</p><p>森林就是这样很多<code>不相交的树组成</code>，同时仅仅一棵树也可以勉强称为森林。即便这有些勉强。。</p><hr><p>森林由树组成，如果我们把树研究明白了，森林就会容易很多。所以我们先研究树。</p><p>在介绍下面的东西时，我们不得不引入树的一些相关术语，便于我们去进一步讨论。</p><h2 id=术语介绍><a class=markdownIt-Anchor href=#术语介绍></a> 术语介绍</h2><p><img data-src=https://s2.loli.net/2022/09/19/xy1uo64FKhNpOLj.png alt=image-20220919171417169>{height=“300px” width=“300px”}</p><p>这棵树上的小圆圈，叫<code>结点</code>。</p><p>A是B、C、D的<code>父结点</code>。B、C、D是A的<code>子结点</code>。而A没有父结点，又称为根结点。</p><p>K、L这些没有子节点的，又称为<code>叶子结点</code>。</p><p>还记得之前学过的离散数学吗？有个叫<code>度</code>的东西。这里我们临时先画一棵简单的树</p><p><img data-src=https://s2.loli.net/2022/09/19/DtUOaJXk3rq8xgi.png alt=image-20220919171620732>{height=“250px” width=“250px”}</p><p>这棵树，很像离散数学的有向图。而树中每个结点的度数，就是这里结点的<code>出度</code>。</p><ul><li>结点a的度数2</li><li>结点c的度数0</li><li>结点b的度数0</li></ul><p>所以树结点的度数就是[该结点连接的子结点个数]{.red}</p><p>树的度就是全部结点中的最大度数。</p><p>好，忘掉刚刚那个图，回到之前的图中。</p><p><img data-src=https://s2.loli.net/2022/09/19/xy1uo64FKhNpOLj.png alt=image-20220919171417169>{height=“300px” width=“300px”}</p><p>树的层数，就是看有几层。</p><p>树的深度等于层数。这个数就是4层，深度为4.</p><p>C、G这样就是一棵子树，子树的深度，就是从当前的层数往下数有多少层，C、G这个深度就是2。而D、H、M这个就是3。</p><p>[重点是树的性质！]{.red}</p><h2 id=树的性质><a class=markdownIt-Anchor href=#树的性质></a> 树的性质</h2><p><img data-src=https://s2.loli.net/2022/09/19/DtUOaJXk3rq8xgi.png alt=image-20220919171620732>{height=“250px” width=“250px”}</p><p>因为刚刚说，每个结点的度就是出度，一个出度就对应一条边。</p><p>所以，度数=边数。</p><p>从下往上看，每个子节点都有一个父节点，即对应一条边连接子、父结点，只有根结点没有父节点。</p><p>所以，结点个数-1 = 边数</p><h3 id=总结><a class=markdownIt-Anchor href=#总结></a> 总结</h3><p>度数=边数=结点个数-1</p><p>不妨来一个简单的小问题</p><ol><li>在一棵度为4的树T中，若有20个度数为4的结点，10个度为3的结点，1个度为2的结点，10个度为1的结点，则树T的叶节点个数是[]{.gap}。{.quiz}<ul><li>41</li><li>82 {.correct}</li><li>113</li><li>122<br>{.options}</li></ul><blockquote><p>解析如下<br>因为边数=度数，叶子结点度数为0<br>所以，边数= 20x4+10x3+1x2+10x2=122，又因为，边数=结点个数-1<br>边数 = 20+10+1+10-1 + 叶子结点<br>所以，叶子结点 = 122-40 = 82</p></blockquote></li></ol><hr><p>树的学习暂时告一段落，树在计算机中，并不容易表示，因此有大佬给出了二叉树，它具有唯一性，并且方便计算机操作。</p><p>学了这么多，还没有见过代码，请不要失望！下面将带你走进计算机与树。</p><h1 id=二叉树><a class=markdownIt-Anchor href=#二叉树></a> 二叉树</h1><p><img data-src=https://s2.loli.net/2022/09/19/z43TM2bBVn7k6O9.png alt=image-20220919180830179>{height=“300px” width=“300px”}</p><p>二叉树是一棵有序树，树的度为2。</p><p>翻译一下</p><ul><li>二叉树有序</li><li>每个结点的度数最大是2</li></ul><p>如果有三个结点，那么会有5种形状的二叉树。</p><p><img data-src=https://s2.loli.net/2022/09/19/3HBActni5fpJg4k.png alt=image-20220919181106537>{height=“200px” width=“300px”}</p><p>二叉树中，有两种值得我们去关注的特殊情况</p><ul><li><p>满二叉树，除最后一层外，其余层结点度数全部为2。</p></li><li><p>完全二叉树，按照编号顺序排列的二叉树。</p></li></ul><p>举个栗子</p><p>满二叉树</p><p><img data-src=https://s2.loli.net/2022/09/19/Ab9iseSdIC52pBJ.png alt=image-20220919180830179>{height=“300px” width=“300px”}</p><p>完全二叉树</p><p><img data-src=https://s2.loli.net/2022/09/19/z43TM2bBVn7k6O9.png alt=image-20220919180830179>{height=“300px” width=“300px”}</p><p>满二叉树不难理解，完全二叉树就是每层从左到右依次放入结点，从顶层开始。</p><p><img data-src=https://s2.loli.net/2022/09/19/7DMOp2HcqiNQZgk.png alt=image-20220919200839322>{height=“300px” width=“300px”}</p><p>这个就不是，第三层没有按照顺序放。</p><hr><p>树的性质同样适用于二叉树。那么我们根据树的性质，很容易得到二叉树的一些性质。</p><h2 id=二叉树的性质><a class=markdownIt-Anchor href=#二叉树的性质></a> 二叉树的性质</h2><ol><li>叶子结点个数 = 度为2的结点个数+1</li></ol><p>​	边数 = 结点度数 = n1 + 2xn2</p><p>​	这里n1为度数为1的结点个数，n2为度数为2的结点个数，依次类推。</p><p>​	边数 = 结点个数-1 = n0+n1+n2-1</p><p>​	所以，n0 = n2+1</p><ol start=2><li><p>第i层，最多有<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=application/x-tex>2^{i-1}</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:0.824664em;vertical-align:0em;></span><span class=mord><span class=mord>2</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:0.824664em;><span style=top:-3.063em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>个结点，一个i层二叉树，最多有<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msup><mn>2</mn><mi>i</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=application/x-tex>2^{i}-1</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:0.907994em;vertical-align:-0.08333em;></span><span class=mord><span class=mord>2</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:0.824664em;><span style=top:-3.063em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span><span class=mspace style=margin-right:0.2222222222222222em;></span><span class=mbin>−</span><span class=mspace style=margin-right:0.2222222222222222em;></span></span><span class=base><span class=strut style=height:0.64444em;vertical-align:0em;></span><span class=mord>1</span></span></span></span>个结点。</p><p>假设有i=3，满二叉树时，结点最多。</p><p>第一层 1个</p><p>第二层 2个</p><p>第三层 4个</p><p>第四层 8个</p><p>第i层 <span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=application/x-tex>2^{i-1}</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:0.824664em;vertical-align:0em;></span><span class=mord><span class=mord>2</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:0.824664em;><span style=top:-3.063em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 个</p><p>…</p></li></ol><p>​	等比数列，i层就是等比数列前n项和=<span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>a</mi><mn>1</mn><mo stretchy=false>(</mo><mn>1</mn><mo>−</mo><msup><mi>q</mi><mi>n</mi></msup><mo stretchy=false>)</mo><mi mathvariant=normal>/</mi><mo stretchy=false>(</mo><mn>1</mn><mo>−</mo><mi>q</mi><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>a1(1-q^{n})/(1-q)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class="mord mathnormal">a</span><span class=mord>1</span><span class=mopen>(</span><span class=mord>1</span><span class=mspace style=margin-right:0.2222222222222222em;></span><span class=mbin>−</span><span class=mspace style=margin-right:0.2222222222222222em;></span></span><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class=mord><span class="mord mathnormal" style=margin-right:0.03588em;>q</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:0.664392em;><span style=top:-3.063em;margin-right:0.05em;><span class=pstrut style=height:2.7em;></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span><span class=mclose>)</span><span class=mord>/</span><span class=mopen>(</span><span class=mord>1</span><span class=mspace style=margin-right:0.2222222222222222em;></span><span class=mbin>−</span><span class=mspace style=margin-right:0.2222222222222222em;></span></span><span class=base><span class=strut style=height:1em;vertical-align:-0.25em;></span><span class="mord mathnormal" style=margin-right:0.03588em;>q</span><span class=mclose>)</span></span></span></span></p><ol start=3><li>完全二叉树结点序号除2，结果为父节点序号。</li></ol><p>​	<img data-src=https://s2.loli.net/2022/09/19/z43TM2bBVn7k6O9.png alt=image-20220919180830179>{height=“300px” width=“300px”}</p><p>​	4/2 = 2</p><p>​	5/2 = 2（地板除）</p><p>​	结点序号/2，结果都为父节点序号。</p><hr><p>二叉树的性质，十分简单，到现在为止，你已经知道这个二叉树的理论部分了。此后，我们将一起探索二叉树的使用，最后并制作一个简易计算器，如果时间充足，我们将利用哈夫曼编码，来实现一个压缩程序。</p><h2 id=二叉树的存储><a class=markdownIt-Anchor href=#二叉树的存储></a> 二叉树的存储</h2><p>就像前面所学的，二叉树也分为顺序存储、链式存储。</p><h3 id=顺序存储><a class=markdownIt-Anchor href=#顺序存储></a> 顺序存储</h3><p><img data-src=https://s2.loli.net/2022/09/19/z43TM2bBVn7k6O9.png alt=image-20220919180830179>{height=“300px” width=“300px”}</p><pre class="line-numbers language-cpp" data-language=cpp><code class=language-cpp><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>可以这样存储。</p><p>如果不是这样完全二叉树，可以用一个特殊字符补成完全二叉树。</p><p><img data-src=https://s2.loli.net/2022/09/19/xr9MZlQiavbqnC1.png alt=image-20220919201655444>{height=“180px” width=“180px”}</p><p><img data-src=https://s2.loli.net/2022/09/19/J2a1zEeOnkrwYlQ.png alt=image-20220919201705283>{height=“180px” width=“180px”}</p><p>此时就可以存储了</p><pre class="line-numbers language-cpp" data-language=cpp><code class=language-cpp><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span></span></code></pre><p>如果是这样的极端情况会很浪费空间，</p><p>而链式存储可以很好的解决这个问题。</p><h3 id=链式存储><a class=markdownIt-Anchor href=#链式存储></a> 链式存储</h3><p>我们需要定义一个结点数据类型</p><pre class="line-numbers language-cpp" data-language=cpp><code class=language-cpp><span class="token keyword">class</span> <span class="token class-name">node</span><span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> data<span class="token punctuation">;</span>
    node <span class="token operator">*</span> lchild<span class="token punctuation">;</span>
    node <span class="token operator">*</span> rchild<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>稍后我们会主要使用这种存储方式。</p><hr><p>说了这么多，还没有讲如何生成一个二叉树，对二叉树的操作也没有系统化。</p><p>但是请你先不要急着写代码，了解完二叉树的遍历，这些东西将迎刃而解。</p><h2 id=二叉树的遍历><a class=markdownIt-Anchor href=#二叉树的遍历></a> 二叉树的遍历</h2><p>二叉树的遍历，通常采用递归进行操作，这里主要讲述递归操作，了解完这些主要操作，我知道，你肯定觉得很没意思，到时候将介绍其他遍历方式。如果你以前不知道，将会令你大开眼界。</p><p>那么先让我们学习一下三个最常见的遍历操作。</p><ol><li>先序遍历</li><li>中序遍历</li><li>后序遍历</li></ol><p>在这里，我不得不放出来一张生动形象的图片，供大家参考。</p><p><img data-src=https://s2.loli.net/2022/09/19/dtplzwjrPnHSW5B.png alt=image-20220919203316683>{height=“300px” width=“300px”}</p><p>我们使用的递归遍历，每个结点，会经历三次，而先、中、后，三种顺序，分别对应这三次时间段。</p><p>所以，先序就是第一次经过的时候访问该结点，中序是第二次经过的时候，后续是第三次经过的时候。</p><p>接下来，我将按照此树，给出代码以及运行结果。</p><pre class="line-numbers language-cpp" data-language=cpp><code class=language-cpp><span class="token comment">//此数的结点</span>
<span class="token keyword">class</span> <span class="token class-name">node</span><span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> data<span class="token punctuation">;</span>
    node <span class="token operator">*</span> lchild<span class="token punctuation">;</span>
    node <span class="token operator">*</span> rchild<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id=先序遍历><a class=markdownIt-Anchor href=#先序遍历></a> 先序遍历</h3><p>按照第一次经过结点就访问，如图所示的路线经过，依次是<code>根--左--右</code></p><pre class="line-numbers language-cpp" data-language=cpp><code class=language-cpp><span class="token keyword">void</span> <span class="token function">foreachPreOrder</span><span class="token punctuation">(</span>node<span class="token operator">*</span>tree<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>tree<span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span>tree<span class="token operator">-></span>data<span class="token punctuation">;</span>
    <span class="token function">foreachPreOrder</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">foreachPreOrder</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果=&gt;ABDEFGC</p><h3 id=中序遍历><a class=markdownIt-Anchor href=#中序遍历></a> 中序遍历</h3><p>按照第二次经过结点就访问，如图所示的路线经过，依次是<code>左--根--右</code></p><pre class="line-numbers language-cpp" data-language=cpp><code class=language-cpp><span class="token keyword">void</span> <span class="token function">foreachInOrder</span><span class="token punctuation">(</span>node<span class="token operator">*</span>tree<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>tree<span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token function">foreachInOrder</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span>tree<span class="token operator">-></span>data<span class="token punctuation">;</span>
    <span class="token function">foreachInOrder</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果=&gt;DBFEGAC</p><h3 id=后序遍历><a class=markdownIt-Anchor href=#后序遍历></a> 后序遍历</h3><p>按照第三次经过结点就访问，如图所示的路线经过，依次是<code>左--右--根</code></p><pre class="line-numbers language-cpp" data-language=cpp><code class=language-cpp><span class="token keyword">void</span> <span class="token function">foreachPostOrder</span><span class="token punctuation">(</span>node<span class="token operator">*</span>tree<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>tree<span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token function">foreachPostOrder</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">foreachPostOrder</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span>tree<span class="token operator">-></span>data<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果=&gt;DFGEBCA</p><hr><p>应该不难理解这里的遍历过程。接下来，我们将介绍另一种遍历方式。</p><h3 id=层遍历><a class=markdownIt-Anchor href=#层遍历></a> 层遍历</h3><p><img data-src=https://s2.loli.net/2022/09/19/dtplzwjrPnHSW5B.png alt=image-20220919203316683>{height=“300px” width=“300px”}</p><p>逐层进行遍历。这更直观。</p><p>结果=&gt; ABCDEFG。这用大脑太容易写出来了，只需要从第一层到最后一层，每层从左到右排列就可以得到。</p><p>那么，我们如何通过计算机进行这样的遍历呢？</p><p>上面的递归，其实就是用的栈，这里我们采用队列即可实现这样的效果。</p><p>我们先建立一个队列Q。放入tree根结点。</p><p>此时Q=[A]</p><p>把队首元素的左右结点放入Q=[A,B,C]</p><p>再让队首出队Q=[B,C]，result=A</p><p>把队首元素的左右结点放入Q=[B,C,D,E]</p><p>再让队首出队Q=[C,D,E],result=AB</p><p>…依次进行直到Q=[]</p><pre class="line-numbers language-cpp" data-language=cpp><code class=language-cpp><span class="token keyword">void</span> <span class="token function">foreachFloor</span><span class="token punctuation">(</span>node<span class="token operator">*</span>tree<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    queue<span class="token operator">&lt;</span>node<span class="token operator">*</span><span class="token operator">></span> q<span class="token punctuation">;</span>
    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        node<span class="token operator">*</span> top <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>top<span class="token operator">-></span>lchild<span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>top<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>top<span class="token operator">-></span>rchild<span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>top<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        cout<span class="token operator">&lt;&lt;</span>top<span class="token operator">-></span>data<span class="token punctuation">;</span>
        q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>栈和队列，真是让人猝不及防。但不得不说妙啊！</p><hr><p>二叉树的遍历，到这已经说完，然而，二叉树的生成，复制，删除，这些操作，还没讲。接下来，就是这些操作了，学习这些操作前，请务必理清楚<code>遍历</code>。</p><p>由于操作涉及到二叉树的生成，为了让大家更清晰，这里必须要补充一点，遍历结果与二叉树的关系。</p><h2 id=遍历结果确定二叉树><a class=markdownIt-Anchor href=#遍历结果确定二叉树></a> 遍历结果确定二叉树</h2><p>先说结论。</p><ul><li>先序+中序，可以确定二叉树</li><li>后续+中序，可以确定二叉树</li></ul><p>为啥先序+后序不能确定二叉树？我们先将为啥前两种为啥可以确定二叉树</p><p>根据上面的遍历结果</p><p>先序=&gt;ABDEFGC</p><p>中序=&gt;DBFEGAC</p><p>先序中可以看出A为根结点</p><p>那么在中序,DBFEG<code>A</code>C，A的左边为左子树，右边为右子树。</p><p><img data-src=https://s2.loli.net/2022/09/20/JZrOpeV6hndyqPW.png alt=image-20220919212722920>{height=“300px” width=“300px”}</p><p>再看D<code>B</code>FEG在先序中，B在前面，B的左边是左子树，右边是右子树。</p><p><img data-src=https://s2.loli.net/2022/09/20/wZ4HhSRQ2F8xcpJ.png alt=image-20220919212734273>{height=“300px” width=“300px”}</p><p>依次类推，就可以得到一个确定二叉树</p><hr><p>后序+中序同理</p><p>后序=&gt;DFGEBCA</p><p>中序=&gt;DBFEGAC</p><p>由后序可知A为根节点。</p><p>先序中可以看出A为根结点</p><p>那么在中序,DBFEG<code>A</code>C，A的左边为左子树，右边为右子树。</p><p>D<code>B</code>FEG中B在后序排列最靠后，所以B为分界点…</p><hr><p>看懂上面的，可以试一下，如果依靠先序+后续推出二叉树，没办法推出来。</p><h2 id=二叉树的操作><a class=markdownIt-Anchor href=#二叉树的操作></a> 二叉树的操作</h2><h3 id=生成><a class=markdownIt-Anchor href=#生成></a> 生成</h3><p>我们可以根据前面的遍历来生成特定形状的二叉树。</p><p>只需要填充空结点，补成完全二叉树。即可。</p><p>例如，我们可以用顺序存储的方式将数据转换成二叉树。</p><p>我想介绍递归+先序，来生成树。</p><p>例如我们想生成这棵树。</p><p><img data-src=https://s2.loli.net/2022/09/20/LXNDH89l2Wio5Ma.png alt=image-20220919225056910>{height=“300px” width=“300px”}</p><p>需要先写出来先序，注意空结点用#或者特殊符号表示。</p><pre class="line-numbers language-cpp" data-language=cpp><code class=language-cpp><span class="token comment">//先序 string expression = "ABC##DE#G##F##"</span>
<span class="token keyword">class</span> <span class="token class-name">node</span><span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">char</span> data<span class="token punctuation">;</span>
    node <span class="token operator">*</span> lchild<span class="token punctuation">;</span>
    node <span class="token operator">*</span> rchild<span class="token punctuation">;</span>
    <span class="token function">node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">default</span><span class="token punctuation">;</span>
    <span class="token function">node</span><span class="token punctuation">(</span><span class="token keyword">char</span> d<span class="token punctuation">)</span><span class="token operator">:</span>data<span class="token punctuation">&#123;</span>d<span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span>
        lchild <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        rchild <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
string expression <span class="token operator">=</span> <span class="token string">"ABC##DE#G##F##"</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> cnt<span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">createTree</span><span class="token punctuation">(</span>node<span class="token operator">*</span><span class="token operator">&amp;</span>tree<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>cnt<span class="token operator">==</span>expression<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span>expression<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token operator">==</span><span class="token char">'#'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        cnt<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
        tree <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">node</span><span class="token punctuation">(</span>expression<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cnt<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token function">createTree</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">createTree</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id=删除二叉树><a class=markdownIt-Anchor href=#删除二叉树></a> 删除二叉树</h3><p>在最后经过这个结点，也就是第三次经过时，delete掉，并且让指针指向nullptr。</p><pre class="line-numbers language-cpp" data-language=cpp><code class=language-cpp><span class="token keyword">void</span> <span class="token function">clean</span><span class="token punctuation">(</span>node<span class="token operator">*</span> <span class="token operator">&amp;</span>tree<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>tree<span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">;</span>

    <span class="token function">clean</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">clean</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">delete</span> tree<span class="token punctuation">;</span>
    tree <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id=复制><a class=markdownIt-Anchor href=#复制></a> 复制</h3><p>先序复制，类似于生成。要比生成简单很多。</p><p>第一次经过这个节点时，进行复制操作。</p><pre class="line-numbers language-cpp" data-language=cpp><code class=language-cpp><span class="token keyword">void</span> <span class="token function">copy</span><span class="token punctuation">(</span>node<span class="token operator">*</span><span class="token operator">&amp;</span> tree<span class="token punctuation">,</span>node<span class="token operator">*</span><span class="token operator">&amp;</span>viceTree<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>tree<span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">;</span>
    viceTree <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">node</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">copy</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>lchild<span class="token punctuation">,</span>viceTree<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">copy</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>rchild<span class="token punctuation">,</span>viceTree<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language=cpp><code class=language-cpp><span class="token comment">//主函数</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

    node <span class="token operator">*</span>root<span class="token punctuation">;</span>
    <span class="token function">createTree</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">foreachPreOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    node <span class="token operator">*</span>viceRoot<span class="token punctuation">;</span>
    <span class="token function">copy</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>viceRoot<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">clean</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//foreachFloor(root);</span>
    cout<span class="token operator">&lt;&lt;</span>viceRoot<span class="token operator">-></span>data<span class="token punctuation">;</span>
    <span class="token function">foreachFloor</span><span class="token punctuation">(</span>viceRoot<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，给出copy以及clean的结果图。</p><p><img data-src=https://s2.loli.net/2022/09/20/5FUDOQfnERy4TjK.png alt=image-20220920103448252>{height=“300px” width=“450px”}</p><p>可以看到root树已经没有了，而viceroot树是复制的，仍然存在。</p><hr><p>到这里，我们已经完成了二叉树的基本操作，但我们不得不继续探索，仅仅这些只能让我们能够了解二叉树的操作与构成，远不能解决实际问题。下面我们将做一些实例应用二叉树。</p><p>在此之前，我们还需补充几个有意思的操作，让二叉树的操作熟练于心。</p><ul><li>二叉树的深度计算</li><li>二叉树叶子结点数</li></ul><p>大家可以发现，二叉树的操作基本都与遍历有关，所以，请大家一定要熟悉遍历的三种方式，以及遍历一笔图。在这里，不得不再次引用遍历图，来加强大家的印象。</p><p><img data-src=https://s2.loli.net/2022/09/19/dtplzwjrPnHSW5B.png alt=image-20220919203316683>{height=“300px” width=“300px”}</p><h3 id=计算二叉树深度><a class=markdownIt-Anchor href=#计算二叉树深度></a> 计算二叉树深度</h3><p>还拿这个图来说</p><p><img data-src=https://s2.loli.net/2022/09/20/LXNDH89l2Wio5Ma.png alt=image-20220919225056910>{height=“300px” width=“300px”}</p><p>用大脑很容易计算出，深度为5。那么计算机应该怎么得到这个呢。</p><p>一个办法是，后序遍历，就是从最左边的最小面开始。统计左右子树的深度。</p><p>这个栗子。</p><p>C的左子树深度为0，右子树深度为0，C的深度就是两者最大的+1 = 1。</p><p>按照后序遍历，需要到第三次路过时，才会进行统计操作。</p><p>统计D时，应该先统计E,F。</p><p>统计E时，应该先统计G。</p><p>G的左子树深度为0，右子树深度为0，G的深度就是两者最大的+1 = 1。</p><p>E的左子树深度为0，右子树深度为1，E的深度就是两者最大的+1 = 2。</p><p>同C、G，F的深度为1。</p><p>D的左子树深度为2，右子树深度为1，D的深度就是两者最大的+1 = 3。</p><p>B的左子树深度为1，右子树深度为3，B的深度就是两者最大的+1 = 4。</p><p>A的左子树深度为4，右子树深度为0，A的深度就是两者最大的+1 = 5。</p><pre class="line-numbers language-cpp" data-language=cpp><code class=language-cpp><span class="token keyword">int</span> <span class="token function">countDeepth</span><span class="token punctuation">(</span>node<span class="token operator">*</span>tree<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>tree<span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> lDeepth <span class="token operator">=</span> <span class="token function">countDeepth</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> rDeepth <span class="token operator">=</span> <span class="token function">countDeepth</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>lDeepth<span class="token punctuation">,</span>rDeepth<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id=二叉树叶子结点数><a class=markdownIt-Anchor href=#二叉树叶子结点数></a> 二叉树叶子结点数</h3><p>叶子结点的判断是左子树和右子树都是空的，只需要遍历经过结点时，判断左子树和右子树是否为空，如果是叶子结点就返回1。</p><p>先序遍历</p><pre class="line-numbers language-cpp" data-language=cpp><code class=language-cpp><span class="token keyword">int</span> <span class="token function">countLeaf</span><span class="token punctuation">(</span>node<span class="token operator">*</span>tree<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>tree<span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>rchild<span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token operator">&amp;&amp;</span>tree<span class="token operator">-></span>lchild<span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">countLeaf</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token operator">+</span> <span class="token function">countLeaf</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>后序遍历</p><pre class="line-numbers language-cpp" data-language=cpp><code class=language-cpp><span class="token keyword">int</span> <span class="token function">countLeaf</span><span class="token punctuation">(</span>node<span class="token operator">*</span>tree<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>tree<span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token function">countLeaf</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">countLeaf</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>rchild<span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token operator">&amp;&amp;</span>tree<span class="token operator">-></span>lchild<span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> l<span class="token operator">+</span>r<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>中序遍历</p><pre class="line-numbers language-cpp" data-language=cpp><code class=language-cpp><span class="token keyword">int</span> <span class="token function">countLeaf</span><span class="token punctuation">(</span>node<span class="token operator">*</span>tree<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>tree<span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token function">countLeaf</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>rchild<span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token operator">&amp;&amp;</span>tree<span class="token operator">-></span>lchild<span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">countLeaf</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> l<span class="token operator">+</span>r<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>ok，到这里二叉树的基本操作介绍完毕。大家有兴趣可以去查阅一些其他资料。接下来，将会介绍一些二叉树的应用。二叉搜索、哈夫曼编码等等，这些应用在日常中无处不在，值得我们去学习怎么样使用。</p><p>理论必须结合实践，要不然就是空谈了，希望大家把重心放在实践上。</p><h1 id=引用><a class=markdownIt-Anchor href=#引用></a> 引用</h1><ul><li><a target=_blank rel=noopener href=https://www.bilibili.com/video/BV1nJ411V7bd>b站青岛大学-王卓老师</a></li><li>CPP primer</li></ul><h1 id=完整代码><a class=markdownIt-Anchor href=#完整代码></a> 完整代码</h1><pre class="line-numbers language-cpp" data-language=cpp><code class=language-cpp><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">node</span><span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">char</span> data<span class="token punctuation">;</span>
    node <span class="token operator">*</span> lchild<span class="token punctuation">;</span>
    node <span class="token operator">*</span> rchild<span class="token punctuation">;</span>
    <span class="token function">node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">default</span><span class="token punctuation">;</span>
    <span class="token function">node</span><span class="token punctuation">(</span><span class="token keyword">char</span> d<span class="token punctuation">)</span><span class="token operator">:</span>data<span class="token punctuation">&#123;</span>d<span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span>
        lchild <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        rchild <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">foreachPreOrder</span><span class="token punctuation">(</span>node<span class="token operator">*</span><span class="token operator">&amp;</span>tree<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>tree<span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span>tree<span class="token operator">-></span>data<span class="token punctuation">;</span>
    <span class="token function">foreachPreOrder</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">foreachPreOrder</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">foreachFloor</span><span class="token punctuation">(</span>node<span class="token operator">*</span><span class="token operator">&amp;</span>tree<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    queue<span class="token operator">&lt;</span>node<span class="token operator">*</span><span class="token operator">></span> q<span class="token punctuation">;</span>
    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        node<span class="token operator">*</span> top <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>top<span class="token operator">-></span>lchild<span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>top<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>top<span class="token operator">-></span>rchild<span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>top<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        cout<span class="token operator">&lt;&lt;</span>top<span class="token operator">-></span>data<span class="token punctuation">;</span>
        q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

string expression <span class="token operator">=</span> <span class="token string">"ABC##DE#G##F##"</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> cnt<span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>


<span class="token keyword">void</span> <span class="token function">createTree</span><span class="token punctuation">(</span>node<span class="token operator">*</span><span class="token operator">&amp;</span>tree<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>cnt<span class="token operator">==</span>expression<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span>expression<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token operator">==</span><span class="token char">'#'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        cnt<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
        tree <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">node</span><span class="token punctuation">(</span>expression<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cnt<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token function">createTree</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">createTree</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">clean</span><span class="token punctuation">(</span>node<span class="token operator">*</span> <span class="token operator">&amp;</span>tree<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>tree<span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">;</span>

    <span class="token function">clean</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">clean</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">delete</span> tree<span class="token punctuation">;</span>
    tree <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">copy</span><span class="token punctuation">(</span>node<span class="token operator">*</span><span class="token operator">&amp;</span> tree<span class="token punctuation">,</span>node<span class="token operator">*</span><span class="token operator">&amp;</span>viceTree<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>tree<span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">;</span>
    viceTree <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">node</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">copy</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>lchild<span class="token punctuation">,</span>viceTree<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">copy</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>rchild<span class="token punctuation">,</span>viceTree<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">countDeepth</span><span class="token punctuation">(</span>node<span class="token operator">*</span>tree<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>tree<span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> lDeepth <span class="token operator">=</span> <span class="token function">countDeepth</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> rDeepth <span class="token operator">=</span> <span class="token function">countDeepth</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>lDeepth<span class="token punctuation">,</span>rDeepth<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">countLeaf</span><span class="token punctuation">(</span>node<span class="token operator">*</span>tree<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>tree<span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token function">countLeaf</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>rchild<span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token operator">&amp;&amp;</span>tree<span class="token operator">-></span>lchild<span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">countLeaf</span><span class="token punctuation">(</span>tree<span class="token operator">-></span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> l<span class="token operator">+</span>r<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

    node <span class="token operator">*</span>root<span class="token punctuation">;</span>
    <span class="token function">createTree</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>

    cout<span class="token operator">&lt;&lt;</span> <span class="token function">countLeaf</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">&#125;</span><span aria-hidden=true class=line-numbers-rows><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><footer class=post-footer><div class=post-tags><a href=/tags/note/ rel=tag># note</a></div><div class=post-nav><div class=post-nav-item><a href=/leetcode/monotonousStack/ rel=prev title=单调栈><i class="fa fa-chevron-left"></i> 单调栈</a></div><div class=post-nav-item><a href=/CS/dataStruct/tree/patchOfTree/ rel=next title=树与二叉树补充I>树与二叉树补充I <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class=comments id=disqus_thread><noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy; <span itemprop=copyrightYear>2024</span> <span class=with-love><i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>ohayo</span></div><div class=powered-by>由 <a href=https://hexo.io/ rel=noopener target=_blank>Hexo</a> & <a href=https://theme-next.js.org/ rel=noopener target=_blank>NexT.Gemini</a> 强力驱动</div></div></footer><script src=https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin=anonymous></script><script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/next-boot.js></script><script src=https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin=anonymous></script><script src=/js/third-party/search/local-search.js></script><script src=/js/third-party/pace.js></script><script class=next-config data-name=enableMath type=application/json>false</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/copy-tex.min.css integrity="sha256-Wk20U9mS/kHGcSgkjSiRezW5exqT6wAOKwySOaLotXM=" crossorigin=anonymous><script class=next-config data-name=katex type=application/json>{"copy_tex_js":{"url":"https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/copy-tex.min.js","integrity":"sha256-etSqbSVF4+Lwe8MGk/Vanc1sR+mWv+qOG73fxWw9p94="}}</script><script src=/js/third-party/math/katex.js></script><script class=next-config data-name=disqus type=application/json>{"enable":true,"shortname":"ohayo1213","count":true,"i18n":{"disqus":"disqus"}}</script><script src=/js/third-party/comments/disqus.js></script></body></html>